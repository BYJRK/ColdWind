---
title: 事件与委托是怎么一回事？（一）
tags:
    - .NET
    - C#
    - Event
    - Delegate
---

!!! info "提示"
    
    本文只适用于 .NET 初学者，因为涉及内容并不深。但如果你希望查漏补缺，那么欢迎你继续阅读。

要弄清 .NET 中的委托与事件究竟是怎么一回事，对于初学者来说可能并不是一个十分简单的问题。我想你可能听说过这么几种常见说法：

- 委托类似于“函数指针”
- 委托可以用作回调函数
- 事件是对委托的封装

但其实委托与函数指针有许多不同之处：

- 委托是一个类，而函数指针是一个指针
- 委托可以指向多个函数
- 委托可以指向同一个函数多次
- 委托可以记录指向的函数所属的对象

但是如果只是看概念的话，恐怕仍旧是一头雾水。所以本文将从简单的例子开始，一步步地解释委托与事件的概念。

---

## 委托的声明

```csharp
// 首先我们来看在 C# 中如何声明函数
void SayHello();
void Say(string message);
// 以上的函数声明并不包含实现，通常会出现在接口或抽象类中

// 那么其实委托的声明也很类似，只需要在开口加一个 delegate 关键字
delegate void SayHello();
delegate void Say(string message);
```

!!! note "思考"

    委托可以近似理解为函数指针，所以需要一种方式让编译器知道指针指向的函数“长什么样子”。

## 委托类型的实例化

因为委托本质上是一个引用类型，所以它可以被实例化。这句话可以简单理解为，类似于函数指针，委托在声明后，它需要指向一个具体的函数才能使用。

```csharp
// 假定我们现在已经有了两个方法
void SayHello() => Console.WriteLine("hello");
void SayBye() => Console.WriteLine("goodbye");

// 此时我们声明一个和它们“很像”的委托
// 也就是无参且无返回值
delegate void SaySth();

// 然后我们就可以实例化这个委托类型了
// 实例化时需要立即传入一个函数，并且只需要写函数的名字，不需要也不能写传参
var say = new SaySomething(SayHello);

// 此时我们就如同调用一般函数一样调用声明的委托，就可以看到实际调用了 SayHello 方法
say(); // 输出：hello

// 我们可以继续添加其他的函数，让委托“指向”更多的函数
say += SayBye;
// 此时调用 say 委托，就会看到输出了不止一句话
say(); // 输出：hello goodbye
```

未完待续……